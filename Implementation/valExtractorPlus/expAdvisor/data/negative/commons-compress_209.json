{
    "id": 209,
    "expression": "NID",
    "projectName": "commons-compress",
    "commitID": "e3ea7b6607e7c96b9e2b6813c05bfba887c8e226",
    "filePath": "src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java",
    "occurrences": 10,
    "isArithmeticExpression": 1,
    "isGetTypeMethod": 1,
    "expressionList": [
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 952,
                "startColumnNumber": 21,
                "endLineNumber": 952,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 952,
                        "startColumnNumber": 21,
                        "endLineNumber": 952,
                        "endColumnNumber": 37
                    },
                    "nodeContext": "NID.kEmptyStream",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 22,
                        "startLineNumber": 952,
                        "startColumnNumber": 16,
                        "endLineNumber": 952,
                        "endColumnNumber": 38
                    },
                    "nodeContext": "case NID.kEmptyStream:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 22,
                    "startLineNumber": 952,
                    "startColumnNumber": 16,
                    "endLineNumber": 952,
                    "endColumnNumber": 38
                },
                "nodeContext": "case NID.kEmptyStream:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        },
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 956,
                "startColumnNumber": 21,
                "endLineNumber": 956,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 14,
                        "startLineNumber": 956,
                        "startColumnNumber": 21,
                        "endLineNumber": 956,
                        "endColumnNumber": 35
                    },
                    "nodeContext": "NID.kEmptyFile",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 20,
                        "startLineNumber": 956,
                        "startColumnNumber": 16,
                        "endLineNumber": 956,
                        "endColumnNumber": 36
                    },
                    "nodeContext": "case NID.kEmptyFile:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 20,
                    "startLineNumber": 956,
                    "startColumnNumber": 16,
                    "endLineNumber": 956,
                    "endColumnNumber": 36
                },
                "nodeContext": "case NID.kEmptyFile:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        },
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 963,
                "startColumnNumber": 21,
                "endLineNumber": 963,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 9,
                        "startLineNumber": 963,
                        "startColumnNumber": 21,
                        "endLineNumber": 963,
                        "endColumnNumber": 30
                    },
                    "nodeContext": "NID.kAnti",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 15,
                        "startLineNumber": 963,
                        "startColumnNumber": 16,
                        "endLineNumber": 963,
                        "endColumnNumber": 31
                    },
                    "nodeContext": "case NID.kAnti:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 15,
                    "startLineNumber": 963,
                    "startColumnNumber": 16,
                    "endLineNumber": 963,
                    "endColumnNumber": 31
                },
                "nodeContext": "case NID.kAnti:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        },
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 970,
                "startColumnNumber": 21,
                "endLineNumber": 970,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 9,
                        "startLineNumber": 970,
                        "startColumnNumber": 21,
                        "endLineNumber": 970,
                        "endColumnNumber": 30
                    },
                    "nodeContext": "NID.kName",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 15,
                        "startLineNumber": 970,
                        "startColumnNumber": 16,
                        "endLineNumber": 970,
                        "endColumnNumber": 31
                    },
                    "nodeContext": "case NID.kName:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 15,
                    "startLineNumber": 970,
                    "startColumnNumber": 16,
                    "endLineNumber": 970,
                    "endColumnNumber": 31
                },
                "nodeContext": "case NID.kName:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        },
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 996,
                "startColumnNumber": 21,
                "endLineNumber": 996,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 10,
                        "startLineNumber": 996,
                        "startColumnNumber": 21,
                        "endLineNumber": 996,
                        "endColumnNumber": 31
                    },
                    "nodeContext": "NID.kCTime",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 996,
                        "startColumnNumber": 16,
                        "endLineNumber": 996,
                        "endColumnNumber": 32
                    },
                    "nodeContext": "case NID.kCTime:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 16,
                    "startLineNumber": 996,
                    "startColumnNumber": 16,
                    "endLineNumber": 996,
                    "endColumnNumber": 32
                },
                "nodeContext": "case NID.kCTime:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        },
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 1012,
                "startColumnNumber": 21,
                "endLineNumber": 1012,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 10,
                        "startLineNumber": 1012,
                        "startColumnNumber": 21,
                        "endLineNumber": 1012,
                        "endColumnNumber": 31
                    },
                    "nodeContext": "NID.kATime",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 1012,
                        "startColumnNumber": 16,
                        "endLineNumber": 1012,
                        "endColumnNumber": 32
                    },
                    "nodeContext": "case NID.kATime:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 16,
                    "startLineNumber": 1012,
                    "startColumnNumber": 16,
                    "endLineNumber": 1012,
                    "endColumnNumber": 32
                },
                "nodeContext": "case NID.kATime:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        },
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 1028,
                "startColumnNumber": 21,
                "endLineNumber": 1028,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 10,
                        "startLineNumber": 1028,
                        "startColumnNumber": 21,
                        "endLineNumber": 1028,
                        "endColumnNumber": 31
                    },
                    "nodeContext": "NID.kMTime",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 1028,
                        "startColumnNumber": 16,
                        "endLineNumber": 1028,
                        "endColumnNumber": 32
                    },
                    "nodeContext": "case NID.kMTime:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 16,
                    "startLineNumber": 1028,
                    "startColumnNumber": 16,
                    "endLineNumber": 1028,
                    "endColumnNumber": 32
                },
                "nodeContext": "case NID.kMTime:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        },
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 1044,
                "startColumnNumber": 21,
                "endLineNumber": 1044,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 1044,
                        "startColumnNumber": 21,
                        "endLineNumber": 1044,
                        "endColumnNumber": 39
                    },
                    "nodeContext": "NID.kWinAttributes",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 24,
                        "startLineNumber": 1044,
                        "startColumnNumber": 16,
                        "endLineNumber": 1044,
                        "endColumnNumber": 40
                    },
                    "nodeContext": "case NID.kWinAttributes:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 24,
                    "startLineNumber": 1044,
                    "startColumnNumber": 16,
                    "endLineNumber": 1044,
                    "endColumnNumber": 40
                },
                "nodeContext": "case NID.kWinAttributes:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        },
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 1060,
                "startColumnNumber": 21,
                "endLineNumber": 1060,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 13,
                        "startLineNumber": 1060,
                        "startColumnNumber": 21,
                        "endLineNumber": 1060,
                        "endColumnNumber": 34
                    },
                    "nodeContext": "NID.kStartPos",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 19,
                        "startLineNumber": 1060,
                        "startColumnNumber": 16,
                        "endLineNumber": 1060,
                        "endColumnNumber": 35
                    },
                    "nodeContext": "case NID.kStartPos:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 19,
                    "startLineNumber": 1060,
                    "startColumnNumber": 16,
                    "endLineNumber": 1060,
                    "endColumnNumber": 35
                },
                "nodeContext": "case NID.kStartPos:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        },
        {
            "nodeContext": "NID",
            "nodeType": "SimpleName",
            "nodePosition": {
                "charLength": 3,
                "startLineNumber": 1063,
                "startColumnNumber": 21,
                "endLineNumber": 1063,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchCase,expression]",
                    "nodePosition": {
                        "charLength": 10,
                        "startLineNumber": 1063,
                        "startColumnNumber": 21,
                        "endLineNumber": 1063,
                        "endColumnNumber": 31
                    },
                    "nodeContext": "NID.kDummy",
                    "nodeType": "QualifiedName",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 1063,
                        "startColumnNumber": 16,
                        "endLineNumber": 1063,
                        "endColumnNumber": 32
                    },
                    "nodeContext": "case NID.kDummy:",
                    "nodeType": "SwitchCase",
                    "astNodeNumber": 4,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6637,
                        "startLineNumber": 951,
                        "startColumnNumber": 12,
                        "endLineNumber": 1080,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "switch (propertyType) {\ncase NID.kEmptyStream:{\n    isEmptyStream=readBits(header,numFilesInt);\n    break;\n  }\ncase NID.kEmptyFile:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n  }\n  isEmptyFile=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kAnti:{\nif (isEmptyStream == null) {\n  throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti=readBits(header,isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\nif (names[i] == 0 && names[i + 1] == 0) {\n  checkEntryIsInitialized(fileMap,nextFile);\n  fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n  nextName=i + 2;\n  nextFile++;\n}\n}\nif (nextName != names.length || nextFile != numFiles) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\nentryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n",
                    "nodeType": "SwitchStatement",
                    "astNodeNumber": 593,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 6854,
                        "startLineNumber": 945,
                        "startColumnNumber": 21,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 616,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 6867,
                        "startLineNumber": 945,
                        "startColumnNumber": 8,
                        "endLineNumber": 1081,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "while (true) {\n  final int propertyType=getUnsignedByte(header);\n  if (propertyType == 0) {\n    break;\n  }\n  final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n      isEmptyStream=readBits(header,numFilesInt);\n      break;\n    }\ncase NID.kEmptyFile:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n    }\n    isEmptyFile=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kAnti:{\n  if (isEmptyStream == null) {\n    throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n  }\n  isAnti=readBits(header,isEmptyStream.cardinality());\n  break;\n}\ncase NID.kName:{\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\n  throw new IOException(\"File names length invalid\");\n}\nassertFitsIntoInt(\"file names length\",size - 1);\nfinal byte[] names=new byte[(int)(size - 1)];\nheader.get(names);\nint nextFile=0;\nint nextName=0;\nfor (int i=0; i < names.length; i+=2) {\n  if (names[i] == 0 && names[i + 1] == 0) {\n    checkEntryIsInitialized(fileMap,nextFile);\n    fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n    nextName=i + 2;\n    nextFile++;\n  }\n}\nif (nextName != names.length || nextFile != numFiles) {\n  throw new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasCreationDate(timesDefined.get(i));\nif (entryAtIndex.getHasCreationDate()) {\n  entryAtIndex.setCreationDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\nentryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 618,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
                    "nodePosition": {
                        "charLength": 8924,
                        "startLineNumber": 937,
                        "startColumnNumber": 98,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "{\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 878,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
                    "nodePosition": {
                        "charLength": 9018,
                        "startLineNumber": 937,
                        "startColumnNumber": 4,
                        "endLineNumber": 1116,
                        "endColumnNumber": 5
                    },
                    "nodeContext": "private void readFilesInfo(final ByteBuffer header,final Archive archive) throws IOException {\n  final long numFiles=readUint64(header);\n  assertFitsIntoInt(\"numFiles\",numFiles);\n  final int numFilesInt=(int)numFiles;\n  final Map<Integer,SevenZArchiveEntry> fileMap=new HashMap<>();\n  BitSet isEmptyStream=null;\n  BitSet isEmptyFile=null;\n  BitSet isAnti=null;\n  while (true) {\n    final int propertyType=getUnsignedByte(header);\n    if (propertyType == 0) {\n      break;\n    }\n    final long size=readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream:{\n        isEmptyStream=readBits(header,numFilesInt);\n        break;\n      }\ncase NID.kEmptyFile:{\n      if (isEmptyStream == null) {\n        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n      }\n      isEmptyFile=readBits(header,isEmptyStream.cardinality());\n      break;\n    }\ncase NID.kAnti:{\n    if (isEmptyStream == null) {\n      throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n    }\n    isAnti=readBits(header,isEmptyStream.cardinality());\n    break;\n  }\ncase NID.kName:{\n  final int external=getUnsignedByte(header);\n  if (external != 0) {\n    throw new IOException(\"Not implemented\");\n  }\n  if (((size - 1) & 1) != 0) {\n    throw new IOException(\"File names length invalid\");\n  }\n  assertFitsIntoInt(\"file names length\",size - 1);\n  final byte[] names=new byte[(int)(size - 1)];\n  header.get(names);\n  int nextFile=0;\n  int nextName=0;\n  for (int i=0; i < names.length; i+=2) {\n    if (names[i] == 0 && names[i + 1] == 0) {\n      checkEntryIsInitialized(fileMap,nextFile);\n      fileMap.get(nextFile).setName(new String(names,nextName,i - nextName,StandardCharsets.UTF_16LE));\n      nextName=i + 2;\n      nextFile++;\n    }\n  }\n  if (nextName != names.length || nextFile != numFiles) {\n    throw new IOException(\"Error parsing file names\");\n  }\n  break;\n}\ncase NID.kCTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\n  throw new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\n  checkEntryIsInitialized(fileMap,i);\n  final SevenZArchiveEntry entryAtIndex=fileMap.get(i);\n  entryAtIndex.setHasCreationDate(timesDefined.get(i));\n  if (entryAtIndex.getHasCreationDate()) {\n    entryAtIndex.setCreationDate(header.getLong());\n  }\n}\nbreak;\n}\ncase NID.kATime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasAccessDate(timesDefined.get(i));\nif (entryAtIndex.getHasAccessDate()) {\n  entryAtIndex.setAccessDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kMTime:{\nfinal BitSet timesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\nif (entryAtIndex.getHasLastModifiedDate()) {\nentryAtIndex.setLastModifiedDate(header.getLong());\n}\n}\nbreak;\n}\ncase NID.kWinAttributes:{\nfinal BitSet attributesDefined=readAllOrBits(header,numFilesInt);\nfinal int external=getUnsignedByte(header);\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i=0; i < numFilesInt; i++) {\ncheckEntryIsInitialized(fileMap,i);\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nentryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\nif (entryAtIndex.getHasWindowsAttributes()) {\nentryAtIndex.setWindowsAttributes(header.getInt());\n}\n}\nbreak;\n}\ncase NID.kStartPos:{\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\ndefault:{\nif (skipBytesFully(header,size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter=0;\nint emptyFileCounter=0;\nfor (int i=0; i < numFilesInt; i++) {\nfinal SevenZArchiveEntry entryAtIndex=fileMap.get(i);\nif (entryAtIndex == null) {\ncontinue;\n}\nentryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\nif (entryAtIndex.hasStream()) {\nif (archive.subStreamsInfo == null) {\nthrow new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n}\nentryAtIndex.setDirectory(false);\nentryAtIndex.setAntiItem(false);\nentryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nentryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nentryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n}\n else {\nentryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\nentryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\nentryAtIndex.setHasCrc(false);\nentryAtIndex.setSize(0);\n++emptyFileCounter;\n}\n}\nfinal List<SevenZArchiveEntry> entries=new ArrayList<>();\nfor (final SevenZArchiveEntry e : fileMap.values()) {\nif (e != null) {\nentries.add(e);\n}\n}\narchive.files=entries.toArray(new SevenZArchiveEntry[0]);\ncalculateStreamMap(archive);\n}\n",
                    "nodeType": "MethodDeclaration",
                    "astNodeNumber": 894,
                    "astHeight": 15
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
                "nodePosition": {
                    "charLength": 16,
                    "startLineNumber": 1063,
                    "startColumnNumber": 16,
                    "endLineNumber": 1063,
                    "endColumnNumber": 32
                },
                "nodeContext": "case NID.kDummy:",
                "nodeType": "SwitchCase",
                "astNodeNumber": 4,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.commons.compress.archivers.sevenz.NID"
        }
    ],
    "positionList": [
        {
            "charLength": 3,
            "startLineNumber": 952,
            "startColumnNumber": 21,
            "endLineNumber": 952,
            "endColumnNumber": 24
        },
        {
            "charLength": 3,
            "startLineNumber": 956,
            "startColumnNumber": 21,
            "endLineNumber": 956,
            "endColumnNumber": 24
        },
        {
            "charLength": 3,
            "startLineNumber": 963,
            "startColumnNumber": 21,
            "endLineNumber": 963,
            "endColumnNumber": 24
        },
        {
            "charLength": 3,
            "startLineNumber": 970,
            "startColumnNumber": 21,
            "endLineNumber": 970,
            "endColumnNumber": 24
        },
        {
            "charLength": 3,
            "startLineNumber": 996,
            "startColumnNumber": 21,
            "endLineNumber": 996,
            "endColumnNumber": 24
        },
        {
            "charLength": 3,
            "startLineNumber": 1012,
            "startColumnNumber": 21,
            "endLineNumber": 1012,
            "endColumnNumber": 24
        },
        {
            "charLength": 3,
            "startLineNumber": 1028,
            "startColumnNumber": 21,
            "endLineNumber": 1028,
            "endColumnNumber": 24
        },
        {
            "charLength": 3,
            "startLineNumber": 1044,
            "startColumnNumber": 21,
            "endLineNumber": 1044,
            "endColumnNumber": 24
        },
        {
            "charLength": 3,
            "startLineNumber": 1060,
            "startColumnNumber": 21,
            "endLineNumber": 1060,
            "endColumnNumber": 24
        },
        {
            "charLength": 3,
            "startLineNumber": 1063,
            "startColumnNumber": 21,
            "endLineNumber": 1063,
            "endColumnNumber": 24
        }
    ],
    "layoutRelationDataList": [
        {
            "firstKey": 0,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 0,
            "secondKey": 2,
            "layout": 2
        },
        {
            "firstKey": 0,
            "secondKey": 3,
            "layout": 2
        },
        {
            "firstKey": 0,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 0,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 0,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 0,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 0,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 0,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 1,
            "secondKey": 0,
            "layout": 2
        },
        {
            "firstKey": 1,
            "secondKey": 2,
            "layout": 2
        },
        {
            "firstKey": 1,
            "secondKey": 3,
            "layout": 2
        },
        {
            "firstKey": 1,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 1,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 1,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 1,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 1,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 1,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 2,
            "secondKey": 0,
            "layout": 2
        },
        {
            "firstKey": 2,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 2,
            "secondKey": 3,
            "layout": 2
        },
        {
            "firstKey": 2,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 2,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 2,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 2,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 2,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 2,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 0,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 2,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 0,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 2,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 3,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 0,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 2,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 3,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 6,
            "secondKey": 0,
            "layout": 2
        },
        {
            "firstKey": 6,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 6,
            "secondKey": 2,
            "layout": 2
        },
        {
            "firstKey": 6,
            "secondKey": 3,
            "layout": 2
        },
        {
            "firstKey": 6,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 6,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 6,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 6,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 6,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 0,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 2,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 3,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 8,
            "secondKey": 0,
            "layout": 2
        },
        {
            "firstKey": 8,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 8,
            "secondKey": 2,
            "layout": 2
        },
        {
            "firstKey": 8,
            "secondKey": 3,
            "layout": 2
        },
        {
            "firstKey": 8,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 8,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 8,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 8,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 8,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 9,
            "secondKey": 0,
            "layout": 2
        },
        {
            "firstKey": 9,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 9,
            "secondKey": 2,
            "layout": 2
        },
        {
            "firstKey": 9,
            "secondKey": 3,
            "layout": 2
        },
        {
            "firstKey": 9,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 9,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 9,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 9,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 9,
            "secondKey": 8,
            "layout": 2
        }
    ]
}