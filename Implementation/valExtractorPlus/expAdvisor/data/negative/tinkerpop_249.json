{
    "id": 249,
    "expression": "this",
    "projectName": "tinkerpop",
    "commitID": "cf2e3b1a99dee9e45540859202cf784913658e47",
    "filePath": "spark-gremlin/src/main/java/org/apache/tinkerpop/gremlin/spark/process/computer/SparkGraphComputer.java",
    "occurrences": 23,
    "isArithmeticExpression": 1,
    "isGetTypeMethod": 1,
    "expressionList": [
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 145,
                "startColumnNumber": 95,
                "endLineNumber": 145,
                "endColumnNumber": 99
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 145,
                        "startColumnNumber": 95,
                        "endLineNumber": 145,
                        "endColumnNumber": 113
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,expression]",
                    "nodePosition": {
                        "charLength": 26,
                        "startLineNumber": 145,
                        "startColumnNumber": 87,
                        "endLineNumber": 145,
                        "endColumnNumber": 113
                    },
                    "nodeContext": "null == this.vertexProgram",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 5,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
                    "nodePosition": {
                        "charLength": 68,
                        "startLineNumber": 145,
                        "startColumnNumber": 87,
                        "endLineNumber": 145,
                        "endColumnNumber": 155
                    },
                    "nodeContext": "null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram",
                    "nodeType": "ConditionalExpression",
                    "astNodeNumber": 10,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                    "nodePosition": {
                        "charLength": 70,
                        "startLineNumber": 145,
                        "startColumnNumber": 86,
                        "endLineNumber": 145,
                        "endColumnNumber": 156
                    },
                    "nodeContext": "(null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram)",
                    "nodeType": "ParenthesizedExpression",
                    "astNodeNumber": 11,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 145,
                        "startLineNumber": 145,
                        "startColumnNumber": 42,
                        "endLineNumber": 145,
                        "endColumnNumber": 187
                    },
                    "nodeContext": "Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\"",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 20,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
                    "nodePosition": {
                        "charLength": 176,
                        "startLineNumber": 145,
                        "startColumnNumber": 12,
                        "endLineNumber": 145,
                        "endColumnNumber": 188
                    },
                    "nodeContext": "sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\")",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 23,
                    "astHeight": 7
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 177,
                        "startLineNumber": 145,
                        "startColumnNumber": 12,
                        "endLineNumber": 145,
                        "endColumnNumber": 189
                    },
                    "nodeContext": "sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n",
                    "nodeType": "ExpressionStatement",
                    "astNodeNumber": 24,
                    "astHeight": 8
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 177,
                    "startLineNumber": 145,
                    "startColumnNumber": 12,
                    "endLineNumber": 145,
                    "endColumnNumber": 189
                },
                "nodeContext": "sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n",
                "nodeType": "ExpressionStatement",
                "astNodeNumber": 24,
                "astHeight": 8
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 145,
                "startColumnNumber": 137,
                "endLineNumber": 145,
                "endColumnNumber": 141
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,elseExpression]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 145,
                        "startColumnNumber": 137,
                        "endLineNumber": 145,
                        "endColumnNumber": 155
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
                    "nodePosition": {
                        "charLength": 68,
                        "startLineNumber": 145,
                        "startColumnNumber": 87,
                        "endLineNumber": 145,
                        "endColumnNumber": 155
                    },
                    "nodeContext": "null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram",
                    "nodeType": "ConditionalExpression",
                    "astNodeNumber": 10,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                    "nodePosition": {
                        "charLength": 70,
                        "startLineNumber": 145,
                        "startColumnNumber": 86,
                        "endLineNumber": 145,
                        "endColumnNumber": 156
                    },
                    "nodeContext": "(null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram)",
                    "nodeType": "ParenthesizedExpression",
                    "astNodeNumber": 11,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 145,
                        "startLineNumber": 145,
                        "startColumnNumber": 42,
                        "endLineNumber": 145,
                        "endColumnNumber": 187
                    },
                    "nodeContext": "Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\"",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 20,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
                    "nodePosition": {
                        "charLength": 176,
                        "startLineNumber": 145,
                        "startColumnNumber": 12,
                        "endLineNumber": 145,
                        "endColumnNumber": 188
                    },
                    "nodeContext": "sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\")",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 23,
                    "astHeight": 7
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 177,
                        "startLineNumber": 145,
                        "startColumnNumber": 12,
                        "endLineNumber": 145,
                        "endColumnNumber": 189
                    },
                    "nodeContext": "sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n",
                    "nodeType": "ExpressionStatement",
                    "astNodeNumber": 24,
                    "astHeight": 8
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 177,
                    "startLineNumber": 145,
                    "startColumnNumber": 12,
                    "endLineNumber": 145,
                    "endColumnNumber": 189
                },
                "nodeContext": "sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n",
                "nodeType": "ExpressionStatement",
                "astNodeNumber": 24,
                "astHeight": 8
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 145,
                "startColumnNumber": 165,
                "endLineNumber": 145,
                "endColumnNumber": 169
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.InfixExpression,extendedOperands]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 145,
                        "startColumnNumber": 165,
                        "endLineNumber": 145,
                        "endColumnNumber": 181
                    },
                    "nodeContext": "this.mapReducers",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 145,
                        "startLineNumber": 145,
                        "startColumnNumber": 42,
                        "endLineNumber": 145,
                        "endColumnNumber": 187
                    },
                    "nodeContext": "Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\"",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 20,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
                    "nodePosition": {
                        "charLength": 176,
                        "startLineNumber": 145,
                        "startColumnNumber": 12,
                        "endLineNumber": 145,
                        "endColumnNumber": 188
                    },
                    "nodeContext": "sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\")",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 23,
                    "astHeight": 7
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 177,
                        "startLineNumber": 145,
                        "startColumnNumber": 12,
                        "endLineNumber": 145,
                        "endColumnNumber": 189
                    },
                    "nodeContext": "sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n",
                    "nodeType": "ExpressionStatement",
                    "astNodeNumber": 24,
                    "astHeight": 8
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 177,
                    "startLineNumber": 145,
                    "startColumnNumber": 12,
                    "endLineNumber": 145,
                    "endColumnNumber": 189
                },
                "nodeContext": "sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n",
                "nodeType": "ExpressionStatement",
                "astNodeNumber": 24,
                "astHeight": 8
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 155,
                "startColumnNumber": 16,
                "endLineNumber": 155,
                "endColumnNumber": 20
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
                    "nodePosition": {
                        "charLength": 48,
                        "startLineNumber": 155,
                        "startColumnNumber": 16,
                        "endLineNumber": 155,
                        "endColumnNumber": 64
                    },
                    "nodeContext": "this.loadJars(sparkContext,hadoopConfiguration)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 5,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 49,
                        "startLineNumber": 155,
                        "startColumnNumber": 16,
                        "endLineNumber": 155,
                        "endColumnNumber": 65
                    },
                    "nodeContext": "this.loadJars(sparkContext,hadoopConfiguration);\n",
                    "nodeType": "ExpressionStatement",
                    "astNodeNumber": 6,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 49,
                    "startLineNumber": 155,
                    "startColumnNumber": 16,
                    "endLineNumber": 155,
                    "endColumnNumber": 65
                },
                "nodeContext": "this.loadJars(sparkContext,hadoopConfiguration);\n",
                "nodeType": "ExpressionStatement",
                "astNodeNumber": 6,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 162,
                "startColumnNumber": 24,
                "endLineNumber": 162,
                "endColumnNumber": 28
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
                    "nodePosition": {
                        "charLength": 15,
                        "startLineNumber": 162,
                        "startColumnNumber": 24,
                        "endLineNumber": 162,
                        "endColumnNumber": 39
                    },
                    "nodeContext": "this.workersSet",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                    "nodePosition": {
                        "charLength": 62,
                        "startLineNumber": 162,
                        "startColumnNumber": 24,
                        "endLineNumber": 162,
                        "endColumnNumber": 86
                    },
                    "nodeContext": "this.workersSet && graphRDD.partitions().size() > this.workers",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 13,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 207,
                        "startLineNumber": 162,
                        "startColumnNumber": 20,
                        "endLineNumber": 163,
                        "endColumnNumber": 67
                    },
                    "nodeContext": "if (this.workersSet && graphRDD.partitions().size() > this.workers) graphRDD=graphRDD.coalesce(this.workers);\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 23,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 808,
                        "startLineNumber": 158,
                        "startColumnNumber": 20,
                        "endLineNumber": 166,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n  if (this.workersSet && graphRDD.partitions().size() > this.workers)   graphRDD=graphRDD.coalesce(this.workers);\n  graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 61,
                    "astHeight": 9
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 968,
                        "startLineNumber": 158,
                        "startColumnNumber": 16,
                        "endLineNumber": 168,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "try {\n  graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n  if (this.workersSet && graphRDD.partitions().size() > this.workers)   graphRDD=graphRDD.coalesce(this.workers);\n  graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n}\n catch (final InstantiationException|IllegalAccessException e) {\n  throw new IllegalStateException(e.getMessage(),e);\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 80,
                    "astHeight": 10
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                "nodePosition": {
                    "charLength": 62,
                    "startLineNumber": 162,
                    "startColumnNumber": 24,
                    "endLineNumber": 162,
                    "endColumnNumber": 86
                },
                "nodeContext": "this.workersSet && graphRDD.partitions().size() > this.workers",
                "nodeType": "InfixExpression",
                "astNodeNumber": 13,
                "astHeight": 5
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 162,
                "startColumnNumber": 74,
                "endLineNumber": 162,
                "endColumnNumber": 78
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                    "nodePosition": {
                        "charLength": 12,
                        "startLineNumber": 162,
                        "startColumnNumber": 74,
                        "endLineNumber": 162,
                        "endColumnNumber": 86
                    },
                    "nodeContext": "this.workers",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                    "nodePosition": {
                        "charLength": 43,
                        "startLineNumber": 162,
                        "startColumnNumber": 43,
                        "endLineNumber": 162,
                        "endColumnNumber": 86
                    },
                    "nodeContext": "graphRDD.partitions().size() > this.workers",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 9,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                    "nodePosition": {
                        "charLength": 62,
                        "startLineNumber": 162,
                        "startColumnNumber": 24,
                        "endLineNumber": 162,
                        "endColumnNumber": 86
                    },
                    "nodeContext": "this.workersSet && graphRDD.partitions().size() > this.workers",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 13,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 207,
                        "startLineNumber": 162,
                        "startColumnNumber": 20,
                        "endLineNumber": 163,
                        "endColumnNumber": 67
                    },
                    "nodeContext": "if (this.workersSet && graphRDD.partitions().size() > this.workers) graphRDD=graphRDD.coalesce(this.workers);\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 23,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 808,
                        "startLineNumber": 158,
                        "startColumnNumber": 20,
                        "endLineNumber": 166,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n  if (this.workersSet && graphRDD.partitions().size() > this.workers)   graphRDD=graphRDD.coalesce(this.workers);\n  graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 61,
                    "astHeight": 9
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 968,
                        "startLineNumber": 158,
                        "startColumnNumber": 16,
                        "endLineNumber": 168,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "try {\n  graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n  if (this.workersSet && graphRDD.partitions().size() > this.workers)   graphRDD=graphRDD.coalesce(this.workers);\n  graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n}\n catch (final InstantiationException|IllegalAccessException e) {\n  throw new IllegalStateException(e.getMessage(),e);\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 80,
                    "astHeight": 10
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                "nodePosition": {
                    "charLength": 62,
                    "startLineNumber": 162,
                    "startColumnNumber": 24,
                    "endLineNumber": 162,
                    "endColumnNumber": 86
                },
                "nodeContext": "this.workersSet && graphRDD.partitions().size() > this.workers",
                "nodeType": "InfixExpression",
                "astNodeNumber": 13,
                "astHeight": 5
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 163,
                "startColumnNumber": 53,
                "endLineNumber": 163,
                "endColumnNumber": 57
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 12,
                        "startLineNumber": 163,
                        "startColumnNumber": 53,
                        "endLineNumber": 163,
                        "endColumnNumber": 65
                    },
                    "nodeContext": "this.workers",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
                    "nodePosition": {
                        "charLength": 31,
                        "startLineNumber": 163,
                        "startColumnNumber": 35,
                        "endLineNumber": 163,
                        "endColumnNumber": 66
                    },
                    "nodeContext": "graphRDD.coalesce(this.workers)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 6,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
                    "nodePosition": {
                        "charLength": 42,
                        "startLineNumber": 163,
                        "startColumnNumber": 24,
                        "endLineNumber": 163,
                        "endColumnNumber": 66
                    },
                    "nodeContext": "graphRDD=graphRDD.coalesce(this.workers)",
                    "nodeType": "Assignment",
                    "astNodeNumber": 8,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 43,
                        "startLineNumber": 163,
                        "startColumnNumber": 24,
                        "endLineNumber": 163,
                        "endColumnNumber": 67
                    },
                    "nodeContext": "graphRDD=graphRDD.coalesce(this.workers);\n",
                    "nodeType": "ExpressionStatement",
                    "astNodeNumber": 9,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 207,
                        "startLineNumber": 162,
                        "startColumnNumber": 20,
                        "endLineNumber": 163,
                        "endColumnNumber": 67
                    },
                    "nodeContext": "if (this.workersSet && graphRDD.partitions().size() > this.workers) graphRDD=graphRDD.coalesce(this.workers);\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 23,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 808,
                        "startLineNumber": 158,
                        "startColumnNumber": 20,
                        "endLineNumber": 166,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n  if (this.workersSet && graphRDD.partitions().size() > this.workers)   graphRDD=graphRDD.coalesce(this.workers);\n  graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 61,
                    "astHeight": 9
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 968,
                        "startLineNumber": 158,
                        "startColumnNumber": 16,
                        "endLineNumber": 168,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "try {\n  graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n  if (this.workersSet && graphRDD.partitions().size() > this.workers)   graphRDD=graphRDD.coalesce(this.workers);\n  graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n}\n catch (final InstantiationException|IllegalAccessException e) {\n  throw new IllegalStateException(e.getMessage(),e);\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 80,
                    "astHeight": 10
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                "nodePosition": {
                    "charLength": 43,
                    "startLineNumber": 163,
                    "startColumnNumber": 24,
                    "endLineNumber": 163,
                    "endColumnNumber": 67
                },
                "nodeContext": "graphRDD=graphRDD.coalesce(this.workers);\n",
                "nodeType": "ExpressionStatement",
                "astNodeNumber": 9,
                "astHeight": 5
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 175,
                "startColumnNumber": 28,
                "endLineNumber": 175,
                "endColumnNumber": 32
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 175,
                        "startColumnNumber": 28,
                        "endLineNumber": 175,
                        "endColumnNumber": 46
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                    "nodePosition": {
                        "charLength": 26,
                        "startLineNumber": 175,
                        "startColumnNumber": 20,
                        "endLineNumber": 175,
                        "endColumnNumber": 46
                    },
                    "nodeContext": "null != this.vertexProgram",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 5,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                "nodePosition": {
                    "charLength": 26,
                    "startLineNumber": 175,
                    "startColumnNumber": 20,
                    "endLineNumber": 175,
                    "endColumnNumber": 46
                },
                "nodeContext": "null != this.vertexProgram",
                "nodeType": "InfixExpression",
                "astNodeNumber": 5,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 177,
                "startColumnNumber": 45,
                "endLineNumber": 177,
                "endColumnNumber": 49
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 177,
                        "startColumnNumber": 45,
                        "endLineNumber": 177,
                        "endColumnNumber": 63
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
                    "nodePosition": {
                        "charLength": 67,
                        "startLineNumber": 177,
                        "startColumnNumber": 29,
                        "endLineNumber": 177,
                        "endColumnNumber": 96
                    },
                    "nodeContext": "new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext)",
                    "nodeType": "ClassInstanceCreation",
                    "astNodeNumber": 10,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
                    "nodePosition": {
                        "charLength": 76,
                        "startLineNumber": 177,
                        "startColumnNumber": 20,
                        "endLineNumber": 177,
                        "endColumnNumber": 96
                    },
                    "nodeContext": "memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext)",
                    "nodeType": "Assignment",
                    "astNodeNumber": 12,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 77,
                        "startLineNumber": 177,
                        "startColumnNumber": 20,
                        "endLineNumber": 177,
                        "endColumnNumber": 97
                    },
                    "nodeContext": "memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n",
                    "nodeType": "ExpressionStatement",
                    "astNodeNumber": 13,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 2548,
                        "startLineNumber": 175,
                        "startColumnNumber": 48,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 216,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 77,
                    "startLineNumber": 177,
                    "startColumnNumber": 20,
                    "endLineNumber": 177,
                    "endColumnNumber": 97
                },
                "nodeContext": "memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n",
                "nodeType": "ExpressionStatement",
                "astNodeNumber": 13,
                "astHeight": 5
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 177,
                "startColumnNumber": 65,
                "endLineNumber": 177,
                "endColumnNumber": 69
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 177,
                        "startColumnNumber": 65,
                        "endLineNumber": 177,
                        "endColumnNumber": 81
                    },
                    "nodeContext": "this.mapReducers",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
                    "nodePosition": {
                        "charLength": 67,
                        "startLineNumber": 177,
                        "startColumnNumber": 29,
                        "endLineNumber": 177,
                        "endColumnNumber": 96
                    },
                    "nodeContext": "new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext)",
                    "nodeType": "ClassInstanceCreation",
                    "astNodeNumber": 10,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
                    "nodePosition": {
                        "charLength": 76,
                        "startLineNumber": 177,
                        "startColumnNumber": 20,
                        "endLineNumber": 177,
                        "endColumnNumber": 96
                    },
                    "nodeContext": "memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext)",
                    "nodeType": "Assignment",
                    "astNodeNumber": 12,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 77,
                        "startLineNumber": 177,
                        "startColumnNumber": 20,
                        "endLineNumber": 177,
                        "endColumnNumber": 97
                    },
                    "nodeContext": "memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n",
                    "nodeType": "ExpressionStatement",
                    "astNodeNumber": 13,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 2548,
                        "startLineNumber": 175,
                        "startColumnNumber": 48,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 216,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 77,
                    "startLineNumber": 177,
                    "startColumnNumber": 20,
                    "endLineNumber": 177,
                    "endColumnNumber": 97
                },
                "nodeContext": "memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n",
                "nodeType": "ExpressionStatement",
                "astNodeNumber": 13,
                "astHeight": 5
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 178,
                "startColumnNumber": 20,
                "endLineNumber": 178,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 178,
                        "startColumnNumber": 20,
                        "endLineNumber": 178,
                        "endColumnNumber": 38
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
                    "nodePosition": {
                        "charLength": 32,
                        "startLineNumber": 178,
                        "startColumnNumber": 20,
                        "endLineNumber": 178,
                        "endColumnNumber": 52
                    },
                    "nodeContext": "this.vertexProgram.setup(memory)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 6,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 33,
                        "startLineNumber": 178,
                        "startColumnNumber": 20,
                        "endLineNumber": 178,
                        "endColumnNumber": 53
                    },
                    "nodeContext": "this.vertexProgram.setup(memory);\n",
                    "nodeType": "ExpressionStatement",
                    "astNodeNumber": 7,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 2548,
                        "startLineNumber": 175,
                        "startColumnNumber": 48,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 216,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 33,
                    "startLineNumber": 178,
                    "startColumnNumber": 20,
                    "endLineNumber": 178,
                    "endColumnNumber": 53
                },
                "nodeContext": "this.vertexProgram.setup(memory);\n",
                "nodeType": "ExpressionStatement",
                "astNodeNumber": 7,
                "astHeight": 4
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 181,
                "startColumnNumber": 20,
                "endLineNumber": 181,
                "endColumnNumber": 24
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 181,
                        "startColumnNumber": 20,
                        "endLineNumber": 181,
                        "endColumnNumber": 38
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
                    "nodePosition": {
                        "charLength": 57,
                        "startLineNumber": 181,
                        "startColumnNumber": 20,
                        "endLineNumber": 181,
                        "endColumnNumber": 77
                    },
                    "nodeContext": "this.vertexProgram.storeState(vertexProgramConfiguration)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 6,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 58,
                        "startLineNumber": 181,
                        "startColumnNumber": 20,
                        "endLineNumber": 181,
                        "endColumnNumber": 78
                    },
                    "nodeContext": "this.vertexProgram.storeState(vertexProgramConfiguration);\n",
                    "nodeType": "ExpressionStatement",
                    "astNodeNumber": 7,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 2548,
                        "startLineNumber": 175,
                        "startColumnNumber": 48,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 216,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 58,
                    "startLineNumber": 181,
                    "startColumnNumber": 20,
                    "endLineNumber": 181,
                    "endColumnNumber": 78
                },
                "nodeContext": "this.vertexProgram.storeState(vertexProgramConfiguration);\n",
                "nodeType": "ExpressionStatement",
                "astNodeNumber": 7,
                "astHeight": 4
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 189,
                "startColumnNumber": 28,
                "endLineNumber": 189,
                "endColumnNumber": 32
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 189,
                        "startColumnNumber": 28,
                        "endLineNumber": 189,
                        "endColumnNumber": 46
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                    "nodePosition": {
                        "charLength": 36,
                        "startLineNumber": 189,
                        "startColumnNumber": 28,
                        "endLineNumber": 189,
                        "endColumnNumber": 64
                    },
                    "nodeContext": "this.vertexProgram.terminate(memory)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 6,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 251,
                        "startLineNumber": 189,
                        "startColumnNumber": 24,
                        "endLineNumber": 194,
                        "endColumnNumber": 25
                    },
                    "nodeContext": "if (this.vertexProgram.terminate(memory)) break;\n else {\n  memory.incrIteration();\n  memory.broadcastMemory(sparkContext);\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 18,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
                    "nodePosition": {
                        "charLength": 546,
                        "startLineNumber": 185,
                        "startColumnNumber": 33,
                        "endLineNumber": 195,
                        "endColumnNumber": 21
                    },
                    "nodeContext": "{\n  memory.setInTask(true);\n  viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n  memory.setInTask(false);\n  if (this.vertexProgram.terminate(memory))   break;\n else {\n    memory.incrIteration();\n    memory.broadcastMemory(sparkContext);\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 39,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 559,
                        "startLineNumber": 185,
                        "startColumnNumber": 20,
                        "endLineNumber": 195,
                        "endColumnNumber": 21
                    },
                    "nodeContext": "while (true) {\n  memory.setInTask(true);\n  viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n  memory.setInTask(false);\n  if (this.vertexProgram.terminate(memory))   break;\n else {\n    memory.incrIteration();\n    memory.broadcastMemory(sparkContext);\n  }\n}\n",
                    "nodeType": "WhileStatement",
                    "astNodeNumber": 41,
                    "astHeight": 7
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 2548,
                        "startLineNumber": 175,
                        "startColumnNumber": 48,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 216,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                "nodePosition": {
                    "charLength": 36,
                    "startLineNumber": 189,
                    "startColumnNumber": 28,
                    "endLineNumber": 189,
                    "endColumnNumber": 64
                },
                "nodeContext": "this.vertexProgram.terminate(memory)",
                "nodeType": "MethodInvocation",
                "astNodeNumber": 6,
                "astHeight": 3
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 197,
                "startColumnNumber": 56,
                "endLineNumber": 197,
                "endColumnNumber": 60
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 197,
                        "startColumnNumber": 56,
                        "endLineNumber": 197,
                        "endColumnNumber": 74
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,expression]",
                    "nodePosition": {
                        "charLength": 26,
                        "startLineNumber": 197,
                        "startColumnNumber": 56,
                        "endLineNumber": 197,
                        "endColumnNumber": 82
                    },
                    "nodeContext": "this.vertexProgram == null",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 5,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
                    "nodePosition": {
                        "charLength": 158,
                        "startLineNumber": 197,
                        "startColumnNumber": 56,
                        "endLineNumber": 197,
                        "endColumnNumber": 214
                    },
                    "nodeContext": "this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()])",
                    "nodeType": "ConditionalExpression",
                    "astNodeNumber": 31,
                    "astHeight": 7
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
                    "nodePosition": {
                        "charLength": 179,
                        "startLineNumber": 197,
                        "startColumnNumber": 35,
                        "endLineNumber": 197,
                        "endColumnNumber": 214
                    },
                    "nodeContext": "elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()])",
                    "nodeType": "VariableDeclarationFragment",
                    "astNodeNumber": 33,
                    "astHeight": 8
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 195,
                        "startLineNumber": 197,
                        "startColumnNumber": 20,
                        "endLineNumber": 197,
                        "endColumnNumber": 215
                    },
                    "nodeContext": "final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n",
                    "nodeType": "VariableDeclarationStatement",
                    "astNodeNumber": 39,
                    "astHeight": 9
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 2548,
                        "startLineNumber": 175,
                        "startColumnNumber": 48,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 216,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 195,
                    "startLineNumber": 197,
                    "startColumnNumber": 20,
                    "endLineNumber": 197,
                    "endColumnNumber": 215
                },
                "nodeContext": "final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n",
                "nodeType": "VariableDeclarationStatement",
                "astNodeNumber": 39,
                "astHeight": 9
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 197,
                "startColumnNumber": 101,
                "endLineNumber": 197,
                "endColumnNumber": 105
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 197,
                        "startColumnNumber": 101,
                        "endLineNumber": 197,
                        "endColumnNumber": 119
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 42,
                        "startLineNumber": 197,
                        "startColumnNumber": 101,
                        "endLineNumber": 197,
                        "endColumnNumber": 143
                    },
                    "nodeContext": "this.vertexProgram.getElementComputeKeys()",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 5,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,elseExpression]",
                    "nodePosition": {
                        "charLength": 113,
                        "startLineNumber": 197,
                        "startColumnNumber": 101,
                        "endLineNumber": 197,
                        "endColumnNumber": 214
                    },
                    "nodeContext": "this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()])",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 19,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
                    "nodePosition": {
                        "charLength": 158,
                        "startLineNumber": 197,
                        "startColumnNumber": 56,
                        "endLineNumber": 197,
                        "endColumnNumber": 214
                    },
                    "nodeContext": "this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()])",
                    "nodeType": "ConditionalExpression",
                    "astNodeNumber": 31,
                    "astHeight": 7
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
                    "nodePosition": {
                        "charLength": 179,
                        "startLineNumber": 197,
                        "startColumnNumber": 35,
                        "endLineNumber": 197,
                        "endColumnNumber": 214
                    },
                    "nodeContext": "elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()])",
                    "nodeType": "VariableDeclarationFragment",
                    "astNodeNumber": 33,
                    "astHeight": 8
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 195,
                        "startLineNumber": 197,
                        "startColumnNumber": 20,
                        "endLineNumber": 197,
                        "endColumnNumber": 215
                    },
                    "nodeContext": "final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n",
                    "nodeType": "VariableDeclarationStatement",
                    "astNodeNumber": 39,
                    "astHeight": 9
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 2548,
                        "startLineNumber": 175,
                        "startColumnNumber": 48,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 216,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 195,
                    "startLineNumber": 197,
                    "startColumnNumber": 20,
                    "endLineNumber": 197,
                    "endColumnNumber": 215
                },
                "nodeContext": "final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n",
                "nodeType": "VariableDeclarationStatement",
                "astNodeNumber": 39,
                "astHeight": 9
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 197,
                "startColumnNumber": 163,
                "endLineNumber": 197,
                "endColumnNumber": 167
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 18,
                        "startLineNumber": 197,
                        "startColumnNumber": 163,
                        "endLineNumber": 197,
                        "endColumnNumber": 181
                    },
                    "nodeContext": "this.vertexProgram",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 42,
                        "startLineNumber": 197,
                        "startColumnNumber": 163,
                        "endLineNumber": 197,
                        "endColumnNumber": 205
                    },
                    "nodeContext": "this.vertexProgram.getElementComputeKeys()",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 5,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.ArrayCreation,dimensions]",
                    "nodePosition": {
                        "charLength": 49,
                        "startLineNumber": 197,
                        "startColumnNumber": 163,
                        "endLineNumber": 197,
                        "endColumnNumber": 212
                    },
                    "nodeContext": "this.vertexProgram.getElementComputeKeys().size()",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 7,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 61,
                        "startLineNumber": 197,
                        "startColumnNumber": 152,
                        "endLineNumber": 197,
                        "endColumnNumber": 213
                    },
                    "nodeContext": "new String[this.vertexProgram.getElementComputeKeys().size()]",
                    "nodeType": "ArrayCreation",
                    "astNodeNumber": 12,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,elseExpression]",
                    "nodePosition": {
                        "charLength": 113,
                        "startLineNumber": 197,
                        "startColumnNumber": 101,
                        "endLineNumber": 197,
                        "endColumnNumber": 214
                    },
                    "nodeContext": "this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()])",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 19,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
                    "nodePosition": {
                        "charLength": 158,
                        "startLineNumber": 197,
                        "startColumnNumber": 56,
                        "endLineNumber": 197,
                        "endColumnNumber": 214
                    },
                    "nodeContext": "this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()])",
                    "nodeType": "ConditionalExpression",
                    "astNodeNumber": 31,
                    "astHeight": 7
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
                    "nodePosition": {
                        "charLength": 179,
                        "startLineNumber": 197,
                        "startColumnNumber": 35,
                        "endLineNumber": 197,
                        "endColumnNumber": 214
                    },
                    "nodeContext": "elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()])",
                    "nodeType": "VariableDeclarationFragment",
                    "astNodeNumber": 33,
                    "astHeight": 8
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 195,
                        "startLineNumber": 197,
                        "startColumnNumber": 20,
                        "endLineNumber": 197,
                        "endColumnNumber": 215
                    },
                    "nodeContext": "final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n",
                    "nodeType": "VariableDeclarationStatement",
                    "astNodeNumber": 39,
                    "astHeight": 9
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 2548,
                        "startLineNumber": 175,
                        "startColumnNumber": 48,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 216,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 195,
                    "startLineNumber": 197,
                    "startColumnNumber": 20,
                    "endLineNumber": 197,
                    "endColumnNumber": 215
                },
                "nodeContext": "final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n",
                "nodeType": "VariableDeclarationStatement",
                "astNodeNumber": 39,
                "astHeight": 9
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 201,
                "startColumnNumber": 29,
                "endLineNumber": 201,
                "endColumnNumber": 33
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 12,
                        "startLineNumber": 201,
                        "startColumnNumber": 29,
                        "endLineNumber": 201,
                        "endColumnNumber": 41
                    },
                    "nodeContext": "this.persist",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.PrefixExpression,operand]",
                    "nodePosition": {
                        "charLength": 50,
                        "startLineNumber": 201,
                        "startColumnNumber": 29,
                        "endLineNumber": 201,
                        "endColumnNumber": 79
                    },
                    "nodeContext": "this.persist.equals(GraphComputer.Persist.NOTHING)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 10,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                    "nodePosition": {
                        "charLength": 51,
                        "startLineNumber": 201,
                        "startColumnNumber": 28,
                        "endLineNumber": 201,
                        "endColumnNumber": 79
                    },
                    "nodeContext": "!this.persist.equals(GraphComputer.Persist.NOTHING)",
                    "nodeType": "PrefixExpression",
                    "astNodeNumber": 11,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                    "nodePosition": {
                        "charLength": 279,
                        "startLineNumber": 199,
                        "startColumnNumber": 24,
                        "endLineNumber": 201,
                        "endColumnNumber": 79
                    },
                    "nodeContext": "(hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 32,
                    "astHeight": 7
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 809,
                        "startLineNumber": 199,
                        "startColumnNumber": 20,
                        "endLineNumber": 209,
                        "endColumnNumber": 21
                    },
                    "nodeContext": "if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n  try {\n    hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 73,
                    "astHeight": 11
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 2548,
                        "startLineNumber": 175,
                        "startColumnNumber": 48,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 216,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 2580,
                        "startLineNumber": 175,
                        "startColumnNumber": 16,
                        "endLineNumber": 210,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (null != this.vertexProgram) {\n  memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n  this.vertexProgram.setup(memory);\n  memory.broadcastMemory(sparkContext);\n  final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n  this.vertexProgram.storeState(vertexProgramConfiguration);\n  ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n  ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n  while (true) {\n    memory.setInTask(true);\n    viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n    memory.setInTask(false);\n    if (this.vertexProgram.terminate(memory))     break;\n else {\n      memory.incrIteration();\n      memory.broadcastMemory(sparkContext);\n    }\n  }\n  final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n  graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n  if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    try {\n      hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 222,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                "nodePosition": {
                    "charLength": 51,
                    "startLineNumber": 201,
                    "startColumnNumber": 28,
                    "endLineNumber": 201,
                    "endColumnNumber": 79
                },
                "nodeContext": "!this.persist.equals(GraphComputer.Persist.NOTHING)",
                "nodeType": "PrefixExpression",
                "astNodeNumber": 11,
                "astHeight": 5
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 217,
                "startColumnNumber": 21,
                "endLineNumber": 217,
                "endColumnNumber": 25
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 217,
                        "startColumnNumber": 21,
                        "endLineNumber": 217,
                        "endColumnNumber": 37
                    },
                    "nodeContext": "this.mapReducers",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.PrefixExpression,operand]",
                    "nodePosition": {
                        "charLength": 26,
                        "startLineNumber": 217,
                        "startColumnNumber": 21,
                        "endLineNumber": 217,
                        "endColumnNumber": 47
                    },
                    "nodeContext": "this.mapReducers.isEmpty()",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 5,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                    "nodePosition": {
                        "charLength": 27,
                        "startLineNumber": 217,
                        "startColumnNumber": 20,
                        "endLineNumber": 217,
                        "endColumnNumber": 47
                    },
                    "nodeContext": "!this.mapReducers.isEmpty()",
                    "nodeType": "PrefixExpression",
                    "astNodeNumber": 6,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 1964,
                        "startLineNumber": 217,
                        "startColumnNumber": 16,
                        "endLineNumber": 242,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (!this.mapReducers.isEmpty()) {\n  final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n    vertexWritable.get().dropEdges();\n    return vertexWritable;\n  }\n).cache();\n  for (  final MapReduce mapReduce : this.mapReducers) {\n    final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n    mapReduce.storeState(newApacheConfiguration);\n    final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n    final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n    try {\n      mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n  mapReduceGraphRDD.unpersist();\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 154,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                "nodePosition": {
                    "charLength": 27,
                    "startLineNumber": 217,
                    "startColumnNumber": 20,
                    "endLineNumber": 217,
                    "endColumnNumber": 47
                },
                "nodeContext": "!this.mapReducers.isEmpty()",
                "nodeType": "PrefixExpression",
                "astNodeNumber": 6,
                "astHeight": 4
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 222,
                "startColumnNumber": 53,
                "endLineNumber": 222,
                "endColumnNumber": 57
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,expression]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 222,
                        "startColumnNumber": 53,
                        "endLineNumber": 222,
                        "endColumnNumber": 69
                    },
                    "nodeContext": "this.mapReducers",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 1501,
                        "startLineNumber": 222,
                        "startColumnNumber": 20,
                        "endLineNumber": 240,
                        "endColumnNumber": 21
                    },
                    "nodeContext": "for (final MapReduce mapReduce : this.mapReducers) {\n  final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n  mapReduce.storeState(newApacheConfiguration);\n  final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n  final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n  try {\n    mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n}\n",
                    "nodeType": "EnhancedForStatement",
                    "astNodeNumber": 114,
                    "astHeight": 12
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
                    "nodePosition": {
                        "charLength": 1931,
                        "startLineNumber": 217,
                        "startColumnNumber": 49,
                        "endLineNumber": 242,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "{\n  final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n    vertexWritable.get().dropEdges();\n    return vertexWritable;\n  }\n).cache();\n  for (  final MapReduce mapReduce : this.mapReducers) {\n    final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n    mapReduce.storeState(newApacheConfiguration);\n    final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n    final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n    try {\n      mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n  mapReduceGraphRDD.unpersist();\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 147,
                    "astHeight": 13
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 1964,
                        "startLineNumber": 217,
                        "startColumnNumber": 16,
                        "endLineNumber": 242,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (!this.mapReducers.isEmpty()) {\n  final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n    vertexWritable.get().dropEdges();\n    return vertexWritable;\n  }\n).cache();\n  for (  final MapReduce mapReduce : this.mapReducers) {\n    final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n    mapReduce.storeState(newApacheConfiguration);\n    final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n    final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n    try {\n      mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n  }\n  mapReduceGraphRDD.unpersist();\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 154,
                    "astHeight": 14
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,expression]",
                "nodePosition": {
                    "charLength": 16,
                    "startLineNumber": 222,
                    "startColumnNumber": 53,
                    "endLineNumber": 222,
                    "endColumnNumber": 69
                },
                "nodeContext": "this.mapReducers",
                "nodeType": "FieldAccess",
                "astNodeNumber": 3,
                "astHeight": 2
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 245,
                "startColumnNumber": 134,
                "endLineNumber": 245,
                "endColumnNumber": 138
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 12,
                        "startLineNumber": 245,
                        "startColumnNumber": 134,
                        "endLineNumber": 245,
                        "endColumnNumber": 146
                    },
                    "nodeContext": "this.persist",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                    "nodePosition": {
                        "charLength": 50,
                        "startLineNumber": 245,
                        "startColumnNumber": 134,
                        "endLineNumber": 245,
                        "endColumnNumber": 184
                    },
                    "nodeContext": "this.persist.equals(GraphComputer.Persist.NOTHING)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 10,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                    "nodePosition": {
                        "charLength": 164,
                        "startLineNumber": 245,
                        "startColumnNumber": 20,
                        "endLineNumber": 245,
                        "endColumnNumber": 184
                    },
                    "nodeContext": "!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 24,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 458,
                        "startLineNumber": 245,
                        "startColumnNumber": 16,
                        "endLineNumber": 249,
                        "endColumnNumber": 17
                    },
                    "nodeContext": "if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n  graphRDD.unpersist();\n  if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))   SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n}\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 49,
                    "astHeight": 8
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                "nodePosition": {
                    "charLength": 164,
                    "startLineNumber": 245,
                    "startColumnNumber": 20,
                    "endLineNumber": 245,
                    "endColumnNumber": 184
                },
                "nodeContext": "!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)",
                "nodeType": "InfixExpression",
                "astNodeNumber": 24,
                "astHeight": 6
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 251,
                "startColumnNumber": 162,
                "endLineNumber": 251,
                "endColumnNumber": 166
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
                    "nodePosition": {
                        "charLength": 12,
                        "startLineNumber": 251,
                        "startColumnNumber": 162,
                        "endLineNumber": 251,
                        "endColumnNumber": 174
                    },
                    "nodeContext": "this.persist",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
                    "nodePosition": {
                        "charLength": 50,
                        "startLineNumber": 251,
                        "startColumnNumber": 162,
                        "endLineNumber": 251,
                        "endColumnNumber": 212
                    },
                    "nodeContext": "this.persist.equals(GraphComputer.Persist.NOTHING)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 10,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                    "nodePosition": {
                        "charLength": 192,
                        "startLineNumber": 251,
                        "startColumnNumber": 20,
                        "endLineNumber": 251,
                        "endColumnNumber": 212
                    },
                    "nodeContext": "FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING)",
                    "nodeType": "InfixExpression",
                    "astNodeNumber": 25,
                    "astHeight": 6
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 338,
                        "startLineNumber": 251,
                        "startColumnNumber": 16,
                        "endLineNumber": 252,
                        "endColumnNumber": 140
                    },
                    "nodeContext": "if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING)) FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n",
                    "nodeType": "IfStatement",
                    "astNodeNumber": 39,
                    "astHeight": 7
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
                "nodePosition": {
                    "charLength": 192,
                    "startLineNumber": 251,
                    "startColumnNumber": 20,
                    "endLineNumber": 251,
                    "endColumnNumber": 212
                },
                "nodeContext": "FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING)",
                "nodeType": "InfixExpression",
                "astNodeNumber": 25,
                "astHeight": 6
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 255,
                "startColumnNumber": 103,
                "endLineNumber": 255,
                "endColumnNumber": 107
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 16,
                        "startLineNumber": 255,
                        "startColumnNumber": 103,
                        "endLineNumber": 255,
                        "endColumnNumber": 119
                    },
                    "nodeContext": "this.resultGraph",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
                    "nodePosition": {
                        "charLength": 85,
                        "startLineNumber": 255,
                        "startColumnNumber": 49,
                        "endLineNumber": 255,
                        "endColumnNumber": 134
                    },
                    "nodeContext": "InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 10,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ReturnStatement,expression]",
                    "nodePosition": {
                        "charLength": 139,
                        "startLineNumber": 255,
                        "startColumnNumber": 23,
                        "endLineNumber": 255,
                        "endColumnNumber": 162
                    },
                    "nodeContext": "new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable())",
                    "nodeType": "ClassInstanceCreation",
                    "astNodeNumber": 16,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 147,
                        "startLineNumber": 255,
                        "startColumnNumber": 16,
                        "endLineNumber": 255,
                        "endColumnNumber": 163
                    },
                    "nodeContext": "return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n",
                    "nodeType": "ReturnStatement",
                    "astNodeNumber": 17,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 147,
                    "startLineNumber": 255,
                    "startColumnNumber": 16,
                    "endLineNumber": 255,
                    "endColumnNumber": 163
                },
                "nodeContext": "return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n",
                "nodeType": "ReturnStatement",
                "astNodeNumber": 17,
                "astHeight": 5
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        },
        {
            "nodeContext": "this",
            "nodeType": "ThisExpression",
            "nodePosition": {
                "charLength": 4,
                "startLineNumber": 255,
                "startColumnNumber": 121,
                "endLineNumber": 255,
                "endColumnNumber": 125
            },
            "astNodeNumber": 1,
            "astHeight": 1,
            "parentDataList": [
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 12,
                        "startLineNumber": 255,
                        "startColumnNumber": 121,
                        "endLineNumber": 255,
                        "endColumnNumber": 133
                    },
                    "nodeContext": "this.persist",
                    "nodeType": "FieldAccess",
                    "astNodeNumber": 3,
                    "astHeight": 2
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
                    "nodePosition": {
                        "charLength": 85,
                        "startLineNumber": 255,
                        "startColumnNumber": 49,
                        "endLineNumber": 255,
                        "endColumnNumber": 134
                    },
                    "nodeContext": "InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist)",
                    "nodeType": "MethodInvocation",
                    "astNodeNumber": 10,
                    "astHeight": 3
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.ReturnStatement,expression]",
                    "nodePosition": {
                        "charLength": 139,
                        "startLineNumber": 255,
                        "startColumnNumber": 23,
                        "endLineNumber": 255,
                        "endColumnNumber": 162
                    },
                    "nodeContext": "new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable())",
                    "nodeType": "ClassInstanceCreation",
                    "astNodeNumber": 16,
                    "astHeight": 4
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 147,
                        "startLineNumber": 255,
                        "startColumnNumber": 16,
                        "endLineNumber": 255,
                        "endColumnNumber": 163
                    },
                    "nodeContext": "return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n",
                    "nodeType": "ReturnStatement",
                    "astNodeNumber": 17,
                    "astHeight": 5
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
                    "nodePosition": {
                        "charLength": 7907,
                        "startLineNumber": 150,
                        "startColumnNumber": 16,
                        "endLineNumber": 256,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "{\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 645,
                    "astHeight": 15
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                    "nodePosition": {
                        "charLength": 8071,
                        "startLineNumber": 150,
                        "startColumnNumber": 12,
                        "endLineNumber": 259,
                        "endColumnNumber": 13
                    },
                    "nodeContext": "try {\n  final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n  Spark.create(sparkContext.sc());\n  updateLocalConfiguration(sparkContext,sparkConfiguration);\n  this.loadJars(sparkContext,hadoopConfiguration);\n  JavaPairRDD<Object,VertexWritable> graphRDD;\n  try {\n    graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n    if (this.workersSet && graphRDD.partitions().size() > this.workers)     graphRDD=graphRDD.coalesce(this.workers);\n    graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n  }\n catch (  final InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n  if (null != this.vertexProgram) {\n    memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n    this.vertexProgram.setup(memory);\n    memory.broadcastMemory(sparkContext);\n    final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n    this.vertexProgram.storeState(vertexProgramConfiguration);\n    ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n    ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n    while (true) {\n      memory.setInTask(true);\n      viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n      memory.setInTask(false);\n      if (this.vertexProgram.terminate(memory))       break;\n else {\n        memory.incrIteration();\n        memory.broadcastMemory(sparkContext);\n      }\n    }\n    final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n    graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n    if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      try {\n        hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n  }\n  final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n  if (!this.mapReducers.isEmpty()) {\n    final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n      vertexWritable.get().dropEdges();\n      return vertexWritable;\n    }\n).cache();\n    for (    final MapReduce mapReduce : this.mapReducers) {\n      final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n      mapReduce.storeState(newApacheConfiguration);\n      final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n      final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n      try {\n        mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n      }\n catch (      final InstantiationException|IllegalAccessException e) {\n        throw new IllegalStateException(e.getMessage(),e);\n      }\n    }\n    mapReduceGraphRDD.unpersist();\n  }\n  if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n    graphRDD.unpersist();\n    if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))     SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  }\n  if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))   FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n  finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n  return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n}\n  finally {\n  if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))   Spark.close();\n}\n",
                    "nodeType": "TryStatement",
                    "astNodeNumber": 660,
                    "astHeight": 16
                },
                {
                    "locationInParent": "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
                    "nodePosition": {
                        "charLength": 9309,
                        "startLineNumber": 132,
                        "startColumnNumber": 67,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "{\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "Block",
                    "astNodeNumber": 781,
                    "astHeight": 17
                },
                {
                    "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
                    "nodePosition": {
                        "charLength": 9315,
                        "startLineNumber": 132,
                        "startColumnNumber": 61,
                        "endLineNumber": 260,
                        "endColumnNumber": 9
                    },
                    "nodeContext": "() -> {\n  final long startTime=System.currentTimeMillis();\n  SparkMemory memory=null;\n  final String outputLocation=hadoopConfiguration.get(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION,null);\n  try {\n    if (null != outputLocation && FileSystem.get(hadoopConfiguration).exists(new Path(outputLocation)))     FileSystem.get(hadoopConfiguration).delete(new Path(outputLocation),true);\n  }\n catch (  final IOException e) {\n    throw new IllegalStateException(e.getMessage(),e);\n  }\n  final SparkConf sparkConfiguration=new SparkConf();\n  sparkConfiguration.setAppName(Constants.GREMLIN_HADOOP_SPARK_JOB_PREFIX + (null == this.vertexProgram ? \"No VertexProgram\" : this.vertexProgram) + \"[\"+ this.mapReducers+ \"]\");\n  hadoopConfiguration.forEach(entry -> sparkConfiguration.set(entry.getKey(),entry.getValue()));\n  try {\n    final JavaSparkContext sparkContext=new JavaSparkContext(SparkContext.getOrCreate(sparkConfiguration));\n    Spark.create(sparkContext.sc());\n    updateLocalConfiguration(sparkContext,sparkConfiguration);\n    this.loadJars(sparkContext,hadoopConfiguration);\n    JavaPairRDD<Object,VertexWritable> graphRDD;\n    try {\n      graphRDD=hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_INPUT_RDD,InputFormatRDD.class,InputRDD.class).newInstance().readGraphRDD(apacheConfiguration,sparkContext);\n      if (this.workersSet && graphRDD.partitions().size() > this.workers)       graphRDD=graphRDD.coalesce(this.workers);\n      graphRDD=graphRDD.persist(StorageLevel.fromString(hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_STORAGE_LEVEL,\"MEMORY_ONLY\")));\n    }\n catch (    final InstantiationException|IllegalAccessException e) {\n      throw new IllegalStateException(e.getMessage(),e);\n    }\n    JavaPairRDD<Object,ViewIncomingPayload<Object>> viewIncomingRDD=null;\n    if (null != this.vertexProgram) {\n      memory=new SparkMemory(this.vertexProgram,this.mapReducers,sparkContext);\n      this.vertexProgram.setup(memory);\n      memory.broadcastMemory(sparkContext);\n      final HadoopConfiguration vertexProgramConfiguration=new HadoopConfiguration();\n      this.vertexProgram.storeState(vertexProgramConfiguration);\n      ConfigurationUtils.copy(vertexProgramConfiguration,apacheConfiguration);\n      ConfUtil.mergeApacheIntoHadoopConfiguration(vertexProgramConfiguration,hadoopConfiguration);\n      while (true) {\n        memory.setInTask(true);\n        viewIncomingRDD=SparkExecutor.executeVertexProgramIteration(graphRDD,viewIncomingRDD,memory,vertexProgramConfiguration);\n        memory.setInTask(false);\n        if (this.vertexProgram.terminate(memory))         break;\n else {\n          memory.incrIteration();\n          memory.broadcastMemory(sparkContext);\n        }\n      }\n      final String[] elementComputeKeys=this.vertexProgram == null ? new String[0] : this.vertexProgram.getElementComputeKeys().toArray(new String[this.vertexProgram.getElementComputeKeys().size()]);\n      graphRDD=SparkExecutor.prepareFinalGraphRDD(graphRDD,viewIncomingRDD,elementComputeKeys);\n      if ((hadoopConfiguration.get(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,null) != null || hadoopConfiguration.get(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null) != null) && !this.persist.equals(GraphComputer.Persist.NOTHING)) {\n        try {\n          hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeGraphRDD(apacheConfiguration,graphRDD);\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n    }\n    final Memory.Admin finalMemory=null == memory ? new MapMemory() : new MapMemory(memory);\n    if (!this.mapReducers.isEmpty()) {\n      final JavaPairRDD<Object,VertexWritable> mapReduceGraphRDD=graphRDD.mapValues(vertexWritable -> {\n        vertexWritable.get().dropEdges();\n        return vertexWritable;\n      }\n).cache();\n      for (      final MapReduce mapReduce : this.mapReducers) {\n        final HadoopConfiguration newApacheConfiguration=new HadoopConfiguration(apacheConfiguration);\n        mapReduce.storeState(newApacheConfiguration);\n        final JavaPairRDD mapRDD=SparkExecutor.executeMap((JavaPairRDD)mapReduceGraphRDD,mapReduce,newApacheConfiguration);\n        final JavaPairRDD reduceRDD=(mapReduce.doStage(MapReduce.Stage.REDUCE)) ? SparkExecutor.executeReduce(mapRDD,mapReduce,newApacheConfiguration) : null;\n        try {\n          mapReduce.addResultToMemory(finalMemory,hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,OutputFormatRDD.class,OutputRDD.class).newInstance().writeMemoryRDD(apacheConfiguration,mapReduce.getMemoryKey(),null == reduceRDD ? mapRDD : reduceRDD));\n        }\n catch (        final InstantiationException|IllegalAccessException e) {\n          throw new IllegalStateException(e.getMessage(),e);\n        }\n      }\n      mapReduceGraphRDD.unpersist();\n    }\n    if (!PersistedOutputRDD.class.equals(hadoopConfiguration.getClass(Constants.GREMLIN_SPARK_GRAPH_OUTPUT_RDD,null)) || this.persist.equals(GraphComputer.Persist.NOTHING)) {\n      graphRDD.unpersist();\n      if (apacheConfiguration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))       SparkContextStorage.open().rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    }\n    if (FileOutputFormat.class.isAssignableFrom(hadoopConfiguration.getClass(Constants.GREMLIN_HADOOP_GRAPH_OUTPUT_FORMAT,FileInputFormat.class)) && this.persist.equals(GraphComputer.Persist.NOTHING))     FileSystemStorage.open(hadoopConfiguration).rm(apacheConfiguration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));\n    finalMemory.setRuntime(System.currentTimeMillis() - startTime);\n    return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n  }\n  finally {\n    if (!apacheConfiguration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT,false))     Spark.close();\n  }\n}\n",
                    "nodeType": "LambdaExpression",
                    "astNodeNumber": 782,
                    "astHeight": 18
                }
            ],
            "currentLineData": {
                "locationInParent": "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
                "nodePosition": {
                    "charLength": 147,
                    "startLineNumber": 255,
                    "startColumnNumber": 16,
                    "endLineNumber": 255,
                    "endColumnNumber": 163
                },
                "nodeContext": "return new DefaultComputerResult(InputOutputHelper.getOutputGraph(apacheConfiguration,this.resultGraph,this.persist),finalMemory.asImmutable());\n",
                "nodeType": "ReturnStatement",
                "astNodeNumber": 17,
                "astHeight": 5
            },
            "tokenLength": 1,
            "type": "org.apache.tinkerpop.gremlin.spark.process.computer.SparkGraphComputer"
        }
    ],
    "positionList": [
        {
            "charLength": 4,
            "startLineNumber": 145,
            "startColumnNumber": 95,
            "endLineNumber": 145,
            "endColumnNumber": 99
        },
        {
            "charLength": 4,
            "startLineNumber": 145,
            "startColumnNumber": 137,
            "endLineNumber": 145,
            "endColumnNumber": 141
        },
        {
            "charLength": 4,
            "startLineNumber": 145,
            "startColumnNumber": 165,
            "endLineNumber": 145,
            "endColumnNumber": 169
        },
        {
            "charLength": 4,
            "startLineNumber": 155,
            "startColumnNumber": 16,
            "endLineNumber": 155,
            "endColumnNumber": 20
        },
        {
            "charLength": 4,
            "startLineNumber": 162,
            "startColumnNumber": 24,
            "endLineNumber": 162,
            "endColumnNumber": 28
        },
        {
            "charLength": 4,
            "startLineNumber": 162,
            "startColumnNumber": 74,
            "endLineNumber": 162,
            "endColumnNumber": 78
        },
        {
            "charLength": 4,
            "startLineNumber": 163,
            "startColumnNumber": 53,
            "endLineNumber": 163,
            "endColumnNumber": 57
        },
        {
            "charLength": 4,
            "startLineNumber": 175,
            "startColumnNumber": 28,
            "endLineNumber": 175,
            "endColumnNumber": 32
        },
        {
            "charLength": 4,
            "startLineNumber": 177,
            "startColumnNumber": 45,
            "endLineNumber": 177,
            "endColumnNumber": 49
        },
        {
            "charLength": 4,
            "startLineNumber": 177,
            "startColumnNumber": 65,
            "endLineNumber": 177,
            "endColumnNumber": 69
        },
        {
            "charLength": 4,
            "startLineNumber": 178,
            "startColumnNumber": 20,
            "endLineNumber": 178,
            "endColumnNumber": 24
        },
        {
            "charLength": 4,
            "startLineNumber": 181,
            "startColumnNumber": 20,
            "endLineNumber": 181,
            "endColumnNumber": 24
        },
        {
            "charLength": 4,
            "startLineNumber": 189,
            "startColumnNumber": 28,
            "endLineNumber": 189,
            "endColumnNumber": 32
        },
        {
            "charLength": 4,
            "startLineNumber": 197,
            "startColumnNumber": 56,
            "endLineNumber": 197,
            "endColumnNumber": 60
        },
        {
            "charLength": 4,
            "startLineNumber": 197,
            "startColumnNumber": 101,
            "endLineNumber": 197,
            "endColumnNumber": 105
        },
        {
            "charLength": 4,
            "startLineNumber": 197,
            "startColumnNumber": 163,
            "endLineNumber": 197,
            "endColumnNumber": 167
        },
        {
            "charLength": 4,
            "startLineNumber": 201,
            "startColumnNumber": 29,
            "endLineNumber": 201,
            "endColumnNumber": 33
        },
        {
            "charLength": 4,
            "startLineNumber": 217,
            "startColumnNumber": 21,
            "endLineNumber": 217,
            "endColumnNumber": 25
        },
        {
            "charLength": 4,
            "startLineNumber": 222,
            "startColumnNumber": 53,
            "endLineNumber": 222,
            "endColumnNumber": 57
        },
        {
            "charLength": 4,
            "startLineNumber": 245,
            "startColumnNumber": 134,
            "endLineNumber": 245,
            "endColumnNumber": 138
        },
        {
            "charLength": 4,
            "startLineNumber": 251,
            "startColumnNumber": 162,
            "endLineNumber": 251,
            "endColumnNumber": 166
        },
        {
            "charLength": 4,
            "startLineNumber": 255,
            "startColumnNumber": 103,
            "endLineNumber": 255,
            "endColumnNumber": 107
        },
        {
            "charLength": 4,
            "startLineNumber": 255,
            "startColumnNumber": 121,
            "endLineNumber": 255,
            "endColumnNumber": 125
        }
    ],
    "layoutRelationDataList": [
        {
            "firstKey": 0,
            "secondKey": 1,
            "layout": 2
        },
        {
            "firstKey": 0,
            "secondKey": 2,
            "layout": 4
        },
        {
            "firstKey": 0,
            "secondKey": 3,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 4,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 5,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 6,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 7,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 8,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 9,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 10,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 11,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 12,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 13,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 14,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 15,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 16,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 17,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 18,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 19,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 20,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 21,
            "layout": 7
        },
        {
            "firstKey": 0,
            "secondKey": 22,
            "layout": 7
        },
        {
            "firstKey": 1,
            "secondKey": 0,
            "layout": 1
        },
        {
            "firstKey": 1,
            "secondKey": 2,
            "layout": 3
        },
        {
            "firstKey": 1,
            "secondKey": 3,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 4,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 5,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 6,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 7,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 8,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 9,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 10,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 11,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 12,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 13,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 14,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 15,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 16,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 17,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 18,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 19,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 20,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 21,
            "layout": 6
        },
        {
            "firstKey": 1,
            "secondKey": 22,
            "layout": 6
        },
        {
            "firstKey": 2,
            "secondKey": 0,
            "layout": 1
        },
        {
            "firstKey": 2,
            "secondKey": 1,
            "layout": 1
        },
        {
            "firstKey": 2,
            "secondKey": 3,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 4,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 5,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 6,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 7,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 8,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 9,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 10,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 11,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 12,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 13,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 15,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 16,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 17,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 18,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 19,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 20,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 21,
            "layout": 4
        },
        {
            "firstKey": 2,
            "secondKey": 22,
            "layout": 4
        },
        {
            "firstKey": 3,
            "secondKey": 0,
            "layout": 4
        },
        {
            "firstKey": 3,
            "secondKey": 1,
            "layout": 4
        },
        {
            "firstKey": 3,
            "secondKey": 2,
            "layout": 4
        },
        {
            "firstKey": 3,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 5,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 7,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 10,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 11,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 12,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 13,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 14,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 15,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 16,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 17,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 18,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 19,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 20,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 21,
            "layout": 2
        },
        {
            "firstKey": 3,
            "secondKey": 22,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 0,
            "layout": 7
        },
        {
            "firstKey": 4,
            "secondKey": 1,
            "layout": 7
        },
        {
            "firstKey": 4,
            "secondKey": 2,
            "layout": 7
        },
        {
            "firstKey": 4,
            "secondKey": 3,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 5,
            "layout": 1
        },
        {
            "firstKey": 4,
            "secondKey": 6,
            "layout": 2
        },
        {
            "firstKey": 4,
            "secondKey": 7,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 8,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 9,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 10,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 11,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 12,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 13,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 14,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 15,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 16,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 17,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 18,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 19,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 20,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 21,
            "layout": 5
        },
        {
            "firstKey": 4,
            "secondKey": 22,
            "layout": 5
        },
        {
            "firstKey": 5,
            "secondKey": 0,
            "layout": 8
        },
        {
            "firstKey": 5,
            "secondKey": 1,
            "layout": 8
        },
        {
            "firstKey": 5,
            "secondKey": 2,
            "layout": 8
        },
        {
            "firstKey": 5,
            "secondKey": 3,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 4,
            "layout": 2
        },
        {
            "firstKey": 5,
            "secondKey": 6,
            "layout": 3
        },
        {
            "firstKey": 5,
            "secondKey": 7,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 8,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 9,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 10,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 11,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 12,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 13,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 14,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 15,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 16,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 17,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 18,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 19,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 20,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 21,
            "layout": 6
        },
        {
            "firstKey": 5,
            "secondKey": 22,
            "layout": 6
        },
        {
            "firstKey": 6,
            "secondKey": 0,
            "layout": 9
        },
        {
            "firstKey": 6,
            "secondKey": 1,
            "layout": 9
        },
        {
            "firstKey": 6,
            "secondKey": 2,
            "layout": 9
        },
        {
            "firstKey": 6,
            "secondKey": 3,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 4,
            "layout": 4
        },
        {
            "firstKey": 6,
            "secondKey": 5,
            "layout": 4
        },
        {
            "firstKey": 6,
            "secondKey": 7,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 8,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 9,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 10,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 11,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 12,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 13,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 14,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 15,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 16,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 17,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 18,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 19,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 20,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 21,
            "layout": 7
        },
        {
            "firstKey": 6,
            "secondKey": 22,
            "layout": 7
        },
        {
            "firstKey": 7,
            "secondKey": 0,
            "layout": 5
        },
        {
            "firstKey": 7,
            "secondKey": 1,
            "layout": 5
        },
        {
            "firstKey": 7,
            "secondKey": 2,
            "layout": 5
        },
        {
            "firstKey": 7,
            "secondKey": 3,
            "layout": 3
        },
        {
            "firstKey": 7,
            "secondKey": 4,
            "layout": 3
        },
        {
            "firstKey": 7,
            "secondKey": 5,
            "layout": 3
        },
        {
            "firstKey": 7,
            "secondKey": 6,
            "layout": 3
        },
        {
            "firstKey": 7,
            "secondKey": 8,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 9,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 10,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 11,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 12,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 13,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 14,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 15,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 16,
            "layout": 2
        },
        {
            "firstKey": 7,
            "secondKey": 17,
            "layout": 3
        },
        {
            "firstKey": 7,
            "secondKey": 18,
            "layout": 3
        },
        {
            "firstKey": 7,
            "secondKey": 19,
            "layout": 3
        },
        {
            "firstKey": 7,
            "secondKey": 20,
            "layout": 3
        },
        {
            "firstKey": 7,
            "secondKey": 21,
            "layout": 3
        },
        {
            "firstKey": 7,
            "secondKey": 22,
            "layout": 3
        },
        {
            "firstKey": 8,
            "secondKey": 0,
            "layout": 8
        },
        {
            "firstKey": 8,
            "secondKey": 1,
            "layout": 8
        },
        {
            "firstKey": 8,
            "secondKey": 2,
            "layout": 8
        },
        {
            "firstKey": 8,
            "secondKey": 3,
            "layout": 6
        },
        {
            "firstKey": 8,
            "secondKey": 4,
            "layout": 6
        },
        {
            "firstKey": 8,
            "secondKey": 5,
            "layout": 6
        },
        {
            "firstKey": 8,
            "secondKey": 6,
            "layout": 6
        },
        {
            "firstKey": 8,
            "secondKey": 7,
            "layout": 5
        },
        {
            "firstKey": 8,
            "secondKey": 9,
            "layout": 1
        },
        {
            "firstKey": 8,
            "secondKey": 10,
            "layout": 4
        },
        {
            "firstKey": 8,
            "secondKey": 11,
            "layout": 4
        },
        {
            "firstKey": 8,
            "secondKey": 12,
            "layout": 4
        },
        {
            "firstKey": 8,
            "secondKey": 13,
            "layout": 4
        },
        {
            "firstKey": 8,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 8,
            "secondKey": 15,
            "layout": 4
        },
        {
            "firstKey": 8,
            "secondKey": 16,
            "layout": 4
        },
        {
            "firstKey": 8,
            "secondKey": 17,
            "layout": 6
        },
        {
            "firstKey": 8,
            "secondKey": 18,
            "layout": 6
        },
        {
            "firstKey": 8,
            "secondKey": 19,
            "layout": 6
        },
        {
            "firstKey": 8,
            "secondKey": 20,
            "layout": 6
        },
        {
            "firstKey": 8,
            "secondKey": 21,
            "layout": 6
        },
        {
            "firstKey": 8,
            "secondKey": 22,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 0,
            "layout": 8
        },
        {
            "firstKey": 9,
            "secondKey": 1,
            "layout": 8
        },
        {
            "firstKey": 9,
            "secondKey": 2,
            "layout": 8
        },
        {
            "firstKey": 9,
            "secondKey": 3,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 4,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 5,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 6,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 7,
            "layout": 5
        },
        {
            "firstKey": 9,
            "secondKey": 8,
            "layout": 1
        },
        {
            "firstKey": 9,
            "secondKey": 10,
            "layout": 4
        },
        {
            "firstKey": 9,
            "secondKey": 11,
            "layout": 4
        },
        {
            "firstKey": 9,
            "secondKey": 12,
            "layout": 4
        },
        {
            "firstKey": 9,
            "secondKey": 13,
            "layout": 4
        },
        {
            "firstKey": 9,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 9,
            "secondKey": 15,
            "layout": 4
        },
        {
            "firstKey": 9,
            "secondKey": 16,
            "layout": 4
        },
        {
            "firstKey": 9,
            "secondKey": 17,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 18,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 19,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 20,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 21,
            "layout": 6
        },
        {
            "firstKey": 9,
            "secondKey": 22,
            "layout": 6
        },
        {
            "firstKey": 10,
            "secondKey": 0,
            "layout": 7
        },
        {
            "firstKey": 10,
            "secondKey": 1,
            "layout": 7
        },
        {
            "firstKey": 10,
            "secondKey": 2,
            "layout": 7
        },
        {
            "firstKey": 10,
            "secondKey": 3,
            "layout": 5
        },
        {
            "firstKey": 10,
            "secondKey": 4,
            "layout": 5
        },
        {
            "firstKey": 10,
            "secondKey": 5,
            "layout": 5
        },
        {
            "firstKey": 10,
            "secondKey": 6,
            "layout": 5
        },
        {
            "firstKey": 10,
            "secondKey": 7,
            "layout": 4
        },
        {
            "firstKey": 10,
            "secondKey": 8,
            "layout": 3
        },
        {
            "firstKey": 10,
            "secondKey": 9,
            "layout": 3
        },
        {
            "firstKey": 10,
            "secondKey": 11,
            "layout": 3
        },
        {
            "firstKey": 10,
            "secondKey": 12,
            "layout": 3
        },
        {
            "firstKey": 10,
            "secondKey": 13,
            "layout": 3
        },
        {
            "firstKey": 10,
            "secondKey": 14,
            "layout": 3
        },
        {
            "firstKey": 10,
            "secondKey": 15,
            "layout": 3
        },
        {
            "firstKey": 10,
            "secondKey": 16,
            "layout": 3
        },
        {
            "firstKey": 10,
            "secondKey": 17,
            "layout": 5
        },
        {
            "firstKey": 10,
            "secondKey": 18,
            "layout": 5
        },
        {
            "firstKey": 10,
            "secondKey": 19,
            "layout": 5
        },
        {
            "firstKey": 10,
            "secondKey": 20,
            "layout": 5
        },
        {
            "firstKey": 10,
            "secondKey": 21,
            "layout": 5
        },
        {
            "firstKey": 10,
            "secondKey": 22,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 0,
            "layout": 7
        },
        {
            "firstKey": 11,
            "secondKey": 1,
            "layout": 7
        },
        {
            "firstKey": 11,
            "secondKey": 2,
            "layout": 7
        },
        {
            "firstKey": 11,
            "secondKey": 3,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 4,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 5,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 6,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 7,
            "layout": 4
        },
        {
            "firstKey": 11,
            "secondKey": 8,
            "layout": 3
        },
        {
            "firstKey": 11,
            "secondKey": 9,
            "layout": 3
        },
        {
            "firstKey": 11,
            "secondKey": 10,
            "layout": 3
        },
        {
            "firstKey": 11,
            "secondKey": 12,
            "layout": 3
        },
        {
            "firstKey": 11,
            "secondKey": 13,
            "layout": 3
        },
        {
            "firstKey": 11,
            "secondKey": 14,
            "layout": 3
        },
        {
            "firstKey": 11,
            "secondKey": 15,
            "layout": 3
        },
        {
            "firstKey": 11,
            "secondKey": 16,
            "layout": 3
        },
        {
            "firstKey": 11,
            "secondKey": 17,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 18,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 19,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 20,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 21,
            "layout": 5
        },
        {
            "firstKey": 11,
            "secondKey": 22,
            "layout": 5
        },
        {
            "firstKey": 12,
            "secondKey": 0,
            "layout": 9
        },
        {
            "firstKey": 12,
            "secondKey": 1,
            "layout": 9
        },
        {
            "firstKey": 12,
            "secondKey": 2,
            "layout": 9
        },
        {
            "firstKey": 12,
            "secondKey": 3,
            "layout": 7
        },
        {
            "firstKey": 12,
            "secondKey": 4,
            "layout": 7
        },
        {
            "firstKey": 12,
            "secondKey": 5,
            "layout": 7
        },
        {
            "firstKey": 12,
            "secondKey": 6,
            "layout": 7
        },
        {
            "firstKey": 12,
            "secondKey": 7,
            "layout": 6
        },
        {
            "firstKey": 12,
            "secondKey": 8,
            "layout": 5
        },
        {
            "firstKey": 12,
            "secondKey": 9,
            "layout": 5
        },
        {
            "firstKey": 12,
            "secondKey": 10,
            "layout": 5
        },
        {
            "firstKey": 12,
            "secondKey": 11,
            "layout": 5
        },
        {
            "firstKey": 12,
            "secondKey": 13,
            "layout": 5
        },
        {
            "firstKey": 12,
            "secondKey": 14,
            "layout": 5
        },
        {
            "firstKey": 12,
            "secondKey": 15,
            "layout": 5
        },
        {
            "firstKey": 12,
            "secondKey": 16,
            "layout": 5
        },
        {
            "firstKey": 12,
            "secondKey": 17,
            "layout": 7
        },
        {
            "firstKey": 12,
            "secondKey": 18,
            "layout": 7
        },
        {
            "firstKey": 12,
            "secondKey": 19,
            "layout": 7
        },
        {
            "firstKey": 12,
            "secondKey": 20,
            "layout": 7
        },
        {
            "firstKey": 12,
            "secondKey": 21,
            "layout": 7
        },
        {
            "firstKey": 12,
            "secondKey": 22,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 0,
            "layout": 9
        },
        {
            "firstKey": 13,
            "secondKey": 1,
            "layout": 9
        },
        {
            "firstKey": 13,
            "secondKey": 2,
            "layout": 9
        },
        {
            "firstKey": 13,
            "secondKey": 3,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 4,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 5,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 6,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 7,
            "layout": 6
        },
        {
            "firstKey": 13,
            "secondKey": 8,
            "layout": 5
        },
        {
            "firstKey": 13,
            "secondKey": 9,
            "layout": 5
        },
        {
            "firstKey": 13,
            "secondKey": 10,
            "layout": 5
        },
        {
            "firstKey": 13,
            "secondKey": 11,
            "layout": 5
        },
        {
            "firstKey": 13,
            "secondKey": 12,
            "layout": 5
        },
        {
            "firstKey": 13,
            "secondKey": 14,
            "layout": 2
        },
        {
            "firstKey": 13,
            "secondKey": 15,
            "layout": 2
        },
        {
            "firstKey": 13,
            "secondKey": 16,
            "layout": 5
        },
        {
            "firstKey": 13,
            "secondKey": 17,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 18,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 19,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 20,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 21,
            "layout": 7
        },
        {
            "firstKey": 13,
            "secondKey": 22,
            "layout": 7
        },
        {
            "firstKey": 14,
            "secondKey": 0,
            "layout": 10
        },
        {
            "firstKey": 14,
            "secondKey": 1,
            "layout": 10
        },
        {
            "firstKey": 14,
            "secondKey": 2,
            "layout": 10
        },
        {
            "firstKey": 14,
            "secondKey": 3,
            "layout": 8
        },
        {
            "firstKey": 14,
            "secondKey": 4,
            "layout": 8
        },
        {
            "firstKey": 14,
            "secondKey": 5,
            "layout": 8
        },
        {
            "firstKey": 14,
            "secondKey": 6,
            "layout": 8
        },
        {
            "firstKey": 14,
            "secondKey": 7,
            "layout": 7
        },
        {
            "firstKey": 14,
            "secondKey": 8,
            "layout": 6
        },
        {
            "firstKey": 14,
            "secondKey": 9,
            "layout": 6
        },
        {
            "firstKey": 14,
            "secondKey": 10,
            "layout": 6
        },
        {
            "firstKey": 14,
            "secondKey": 11,
            "layout": 6
        },
        {
            "firstKey": 14,
            "secondKey": 12,
            "layout": 6
        },
        {
            "firstKey": 14,
            "secondKey": 13,
            "layout": 3
        },
        {
            "firstKey": 14,
            "secondKey": 15,
            "layout": 2
        },
        {
            "firstKey": 14,
            "secondKey": 16,
            "layout": 6
        },
        {
            "firstKey": 14,
            "secondKey": 17,
            "layout": 8
        },
        {
            "firstKey": 14,
            "secondKey": 18,
            "layout": 8
        },
        {
            "firstKey": 14,
            "secondKey": 19,
            "layout": 8
        },
        {
            "firstKey": 14,
            "secondKey": 20,
            "layout": 8
        },
        {
            "firstKey": 14,
            "secondKey": 21,
            "layout": 8
        },
        {
            "firstKey": 14,
            "secondKey": 22,
            "layout": 8
        },
        {
            "firstKey": 15,
            "secondKey": 0,
            "layout": 12
        },
        {
            "firstKey": 15,
            "secondKey": 1,
            "layout": 12
        },
        {
            "firstKey": 15,
            "secondKey": 2,
            "layout": 12
        },
        {
            "firstKey": 15,
            "secondKey": 3,
            "layout": 10
        },
        {
            "firstKey": 15,
            "secondKey": 4,
            "layout": 10
        },
        {
            "firstKey": 15,
            "secondKey": 5,
            "layout": 10
        },
        {
            "firstKey": 15,
            "secondKey": 6,
            "layout": 10
        },
        {
            "firstKey": 15,
            "secondKey": 7,
            "layout": 9
        },
        {
            "firstKey": 15,
            "secondKey": 8,
            "layout": 8
        },
        {
            "firstKey": 15,
            "secondKey": 9,
            "layout": 8
        },
        {
            "firstKey": 15,
            "secondKey": 10,
            "layout": 8
        },
        {
            "firstKey": 15,
            "secondKey": 11,
            "layout": 8
        },
        {
            "firstKey": 15,
            "secondKey": 12,
            "layout": 8
        },
        {
            "firstKey": 15,
            "secondKey": 13,
            "layout": 5
        },
        {
            "firstKey": 15,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 15,
            "secondKey": 16,
            "layout": 8
        },
        {
            "firstKey": 15,
            "secondKey": 17,
            "layout": 10
        },
        {
            "firstKey": 15,
            "secondKey": 18,
            "layout": 10
        },
        {
            "firstKey": 15,
            "secondKey": 19,
            "layout": 10
        },
        {
            "firstKey": 15,
            "secondKey": 20,
            "layout": 10
        },
        {
            "firstKey": 15,
            "secondKey": 21,
            "layout": 10
        },
        {
            "firstKey": 15,
            "secondKey": 22,
            "layout": 10
        },
        {
            "firstKey": 16,
            "secondKey": 0,
            "layout": 9
        },
        {
            "firstKey": 16,
            "secondKey": 1,
            "layout": 9
        },
        {
            "firstKey": 16,
            "secondKey": 2,
            "layout": 9
        },
        {
            "firstKey": 16,
            "secondKey": 3,
            "layout": 7
        },
        {
            "firstKey": 16,
            "secondKey": 4,
            "layout": 7
        },
        {
            "firstKey": 16,
            "secondKey": 5,
            "layout": 7
        },
        {
            "firstKey": 16,
            "secondKey": 6,
            "layout": 7
        },
        {
            "firstKey": 16,
            "secondKey": 7,
            "layout": 6
        },
        {
            "firstKey": 16,
            "secondKey": 8,
            "layout": 5
        },
        {
            "firstKey": 16,
            "secondKey": 9,
            "layout": 5
        },
        {
            "firstKey": 16,
            "secondKey": 10,
            "layout": 5
        },
        {
            "firstKey": 16,
            "secondKey": 11,
            "layout": 5
        },
        {
            "firstKey": 16,
            "secondKey": 12,
            "layout": 5
        },
        {
            "firstKey": 16,
            "secondKey": 13,
            "layout": 5
        },
        {
            "firstKey": 16,
            "secondKey": 14,
            "layout": 5
        },
        {
            "firstKey": 16,
            "secondKey": 15,
            "layout": 5
        },
        {
            "firstKey": 16,
            "secondKey": 17,
            "layout": 7
        },
        {
            "firstKey": 16,
            "secondKey": 18,
            "layout": 7
        },
        {
            "firstKey": 16,
            "secondKey": 19,
            "layout": 7
        },
        {
            "firstKey": 16,
            "secondKey": 20,
            "layout": 7
        },
        {
            "firstKey": 16,
            "secondKey": 21,
            "layout": 7
        },
        {
            "firstKey": 16,
            "secondKey": 22,
            "layout": 7
        },
        {
            "firstKey": 17,
            "secondKey": 0,
            "layout": 6
        },
        {
            "firstKey": 17,
            "secondKey": 1,
            "layout": 6
        },
        {
            "firstKey": 17,
            "secondKey": 2,
            "layout": 6
        },
        {
            "firstKey": 17,
            "secondKey": 3,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 4,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 5,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 6,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 7,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 8,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 9,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 10,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 11,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 12,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 13,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 15,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 16,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 18,
            "layout": 3
        },
        {
            "firstKey": 17,
            "secondKey": 19,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 20,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 21,
            "layout": 4
        },
        {
            "firstKey": 17,
            "secondKey": 22,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 0,
            "layout": 6
        },
        {
            "firstKey": 18,
            "secondKey": 1,
            "layout": 6
        },
        {
            "firstKey": 18,
            "secondKey": 2,
            "layout": 6
        },
        {
            "firstKey": 18,
            "secondKey": 3,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 4,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 5,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 6,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 7,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 8,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 9,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 10,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 11,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 12,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 13,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 15,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 16,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 17,
            "layout": 3
        },
        {
            "firstKey": 18,
            "secondKey": 19,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 20,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 21,
            "layout": 4
        },
        {
            "firstKey": 18,
            "secondKey": 22,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 0,
            "layout": 6
        },
        {
            "firstKey": 19,
            "secondKey": 1,
            "layout": 6
        },
        {
            "firstKey": 19,
            "secondKey": 2,
            "layout": 6
        },
        {
            "firstKey": 19,
            "secondKey": 3,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 4,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 5,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 6,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 7,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 8,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 9,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 10,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 11,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 12,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 13,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 15,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 16,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 17,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 18,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 20,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 21,
            "layout": 4
        },
        {
            "firstKey": 19,
            "secondKey": 22,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 0,
            "layout": 6
        },
        {
            "firstKey": 20,
            "secondKey": 1,
            "layout": 6
        },
        {
            "firstKey": 20,
            "secondKey": 2,
            "layout": 6
        },
        {
            "firstKey": 20,
            "secondKey": 3,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 4,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 5,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 6,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 7,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 8,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 9,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 10,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 11,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 12,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 13,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 15,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 16,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 17,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 18,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 19,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 21,
            "layout": 4
        },
        {
            "firstKey": 20,
            "secondKey": 22,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 0,
            "layout": 6
        },
        {
            "firstKey": 21,
            "secondKey": 1,
            "layout": 6
        },
        {
            "firstKey": 21,
            "secondKey": 2,
            "layout": 6
        },
        {
            "firstKey": 21,
            "secondKey": 3,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 4,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 5,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 6,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 7,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 8,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 9,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 10,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 11,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 12,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 13,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 15,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 16,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 17,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 18,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 19,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 20,
            "layout": 4
        },
        {
            "firstKey": 21,
            "secondKey": 22,
            "layout": 1
        },
        {
            "firstKey": 22,
            "secondKey": 0,
            "layout": 6
        },
        {
            "firstKey": 22,
            "secondKey": 1,
            "layout": 6
        },
        {
            "firstKey": 22,
            "secondKey": 2,
            "layout": 6
        },
        {
            "firstKey": 22,
            "secondKey": 3,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 4,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 5,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 6,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 7,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 8,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 9,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 10,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 11,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 12,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 13,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 14,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 15,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 16,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 17,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 18,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 19,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 20,
            "layout": 4
        },
        {
            "firstKey": 22,
            "secondKey": 21,
            "layout": 1
        }
    ]
}